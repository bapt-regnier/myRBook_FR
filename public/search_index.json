[
["algo.html", " 10 Algorithmique 10.1 Tests logiques avec if 10.2 Tests logiques avec switch 10.3 La boucle for 10.4 La boucle while 10.5 La boucle repeat 10.6 next et break 10.7 Les boucles de la famille apply 10.8 Conclusion", " 10 Algorithmique 10.1 Tests logiques avec if Si nous voulons effectuer une opération différente en fonction d’une condition, nous pouvons mettre en place un test logique du type SI ceci ALORS faire cela SINON faire cela. Avec R cela va se traduire par la fonction if(cond) cons.expr else alt.expr comme indiqué dans l’aide de la fonction. myVar &lt;- 2 if(myVar &lt; 3) print(&quot;myVar &lt; 3&quot;) ## [1] &quot;myVar &lt; 3&quot; if(myVar &lt; 3) print(&quot;myVar &lt; 3&quot;) else print(&quot;myVar &gt; 3&quot;) ## [1] &quot;myVar &lt; 3&quot; Lorsque il y a plusieurs lignes de codes à exécuter en fonction du test logique, ou simplement pour rendre le code plus facile à lire, nous allons utiliser plusieurs lignes avec les acolades {} et en utilisant l’indentation. myVar &lt;- 2 myResult &lt;- 0 if(myVar &lt; 3){ print(&quot;myVar &lt; 3&quot;) myResult &lt;- myVar + 10 } else { print(&quot;myVar &gt; 3&quot;) myResult &lt;- myVar - 10 } ## [1] &quot;myVar &lt; 3&quot; print(myResult) ## [1] 12 Dans cet exemple nous définissons une variable myVar. Si cette variable est inférieure à 3 alors la variable myResult prend comme valeur myVar + 10, et dans le cas contraire myResult prend comme valeur myVar - 10. Nous avions déjà vu l’utilisation du test logique if dans le chapitre sur les fonctions. Nous avions alors testé si la variable entrée comme argument dans notre fonction était bien de type character. myVar &lt;- &quot;qwerty&quot; if(is.character(myVar)){ print(&quot;ok&quot;) } else { print(&quot;error&quot;) } ## [1] &quot;ok&quot; Nous pouvons aussi imbriquer les tests logiques les uns dans les autres. myVar &lt;- TRUE if(is.character(myVar)){ print(&quot;myVar: character&quot;) } else { if(is.numeric(myVar)){ print(&quot;myVar: numeric&quot;) } else { if(is.logical(myVar)){ print(&quot;myVar: logical&quot;) } else { print(&quot;myVar: ...&quot;) } } } ## [1] &quot;myVar: logical&quot; Il est aussi possible de stipuler plusieurs conditions, comme nous l’avons vu lors du chapitre sur les opérateurs de comparaison. myVar &lt;- 2 if(myVar &gt; 1 &amp; myVar &lt; 50){ print(&quot;ok&quot;) } ## [1] &quot;ok&quot; Dans cet exemple myVar est au format numeric donc la première condition (&gt;1), et la seconde condition (&lt;50) sont toutes les deux vérifiables. Par contre si nous affectons une variable de type character à myVar alors R va transformer 0 et 10 en objets de type character et tester si myVar &gt; &quot;1&quot; puis si myVar &lt; &quot;50&quot; en se basant sur un tri par ordre alphabétique. Dans l’exemple suivant &quot;azerty&quot; n’est pas situé par ordre alphabétique entre &quot;1&quot; et &quot;50&quot;, par contre c’est le cas de &quot;2azerty&quot;. myVar &lt;- &quot;azerty&quot; limInit &lt;- 1 limEnd &lt;- 50 if(myVar &gt; limInit &amp; myVar &lt; limEnd){ print(paste0(myVar, &quot; is between &quot;, limInit, &quot; and &quot;, limEnd, &quot;.&quot;)) } else { print(paste0(myVar, &quot; not between &quot;, limInit, &quot; and &quot;, limEnd, &quot;.&quot;)) } ## [1] &quot;azerty not between 1 and 50.&quot; myVar &lt;- &quot;2azerty&quot; if(myVar &gt; limInit &amp; myVar &lt; limEnd){ print(paste0(myVar, &quot; is between &quot;, limInit, &quot; and &quot;, limEnd, &quot;.&quot;)) } else { print(paste0(myVar, &quot; not between &quot;, limInit, &quot; and &quot;, limEnd, &quot;.&quot;)) } ## [1] &quot;2azerty is between 1 and 50.&quot; Donc ce que nous voudrions faire est de tester si myVar est bien au format numeric puis uniquement si c’est le cas de tester les conditions suivantes. myVar &lt;- &quot;2azerty&quot; if(is.numeric(myVar)){ if(myVar &gt; limInit &amp; myVar &lt; limEnd){ print(paste0(myVar, &quot; is between &quot;, limInit, &quot; and &quot;, limEnd, &quot;.&quot;)) } else { print(paste0(myVar, &quot; not between &quot;, limInit, &quot; and &quot;, limEnd, &quot;.&quot;)) } } else { print(paste0(&quot;Object &quot;, myVar, &quot; is not numeric&quot;)) } ## [1] &quot;Object 2azerty is not numeric&quot; Parfois, nous pouvons avoir besoin de tester une première condition puis une seconde condition uniquement si la première se vérifie dans un même test. Par exemple, pour un site nous voudrions savoir si il y a une seule espèces et tester si son abondance est supérieure à 10. Imaginons un jeu de données avec sous forme de vecteur les abondances. Nous allons tester le nombre d’espèces avec la fonction length(). mySpecies &lt;- c(15, 14, 20, 12) if(length(mySpecies) == 1 &amp; mySpecies &gt; 10){ print(&quot;ok!&quot;) } ## Warning message: ## In if (length(mySpecies) == 1 &amp; mySpecies &gt; 10) { : ## the condition has length &gt; 1 and only the first element will be used R renvoie une erreur car il ne peut pas au sein d’un test logique avec if() vérifier la seconde condition. En effet, mySpecies &gt; 10 renvoie TRUE TRUE TRUE TRUE TRUE. Nous pouvons séparer le code en deux conditions : mySpecies &lt;- c(15, 14, 20, 12) if(length(mySpecies) == 1){ if(mySpecies &gt; 10){ print(&quot;ok!&quot;) } } Une alternative plus élégante consiste à spécifier à R de vérifier la seconde condition uniquement si la première est vraie. Pour cela nous pouvons utiliser &amp;&amp; à la place de &amp;. mySpecies &lt;- c(15, 14, 20, 12) if(length(mySpecies) == 1 &amp;&amp; mySpecies &gt; 10){ print(&quot;ok!&quot;) } mySpecies &lt;- 15 if(length(mySpecies) == 1 &amp;&amp; mySpecies &gt; 10){ print(&quot;ok!&quot;) } ## [1] &quot;ok!&quot; mySpecies &lt;- 5 if(length(mySpecies) == 1 &amp;&amp; mySpecies &gt; 10){ print(&quot;ok!&quot;) } Avec &amp; R va vérifier toutes les conditions, et avec &amp;&amp; R va prendre chaque condition l’une après l’autre et poursuivre uniquement si elle se vérifie. Cela peut paraître anecdotique mais il est bon de connaître la différence entre &amp; et &amp;&amp; car nous les rencontrons souvent dans les codes disponibles sur Internet ou dans les packages. 10.2 Tests logiques avec switch La fonction switch() est une variante de if() qui est utile lorsque nous avons de nombreuses options possibles sur une même expression. L’exemple suivant montre comment transformer un code utilisant if() en switch(). x &lt;- &quot;aa&quot; if(x == &quot;a&quot;){ result &lt;- 1 } if(x == &quot;aa&quot;){ result &lt;- 2 } if(x == &quot;aaa&quot;){ result &lt;- 3 } if(x == &quot;aaaa&quot;){ result &lt;- 4 } print(result) ## [1] 2 x &lt;- &quot;aa&quot; switch(x, a = result &lt;- 1, aa = result &lt;- 2, aaa = result &lt;- 3, aaaa = result &lt;- 4) print(result) ## [1] 2 10.3 La boucle for En programmation, lorsque nous sommes amenés à répéter plusieurs fois la même ligne de code, c’est un signe indiquant qu’il faut utiliser une boucle. Une boucle est une manière d’itérer sur un ensemble d’objets (ou sur les éléments d’un objet), et de répéter une opération. Imaginons une data.frame avec des mesures de terrain à deux dates. bdd &lt;- data.frame(date01 = rnorm(n = 100, mean = 10, sd = 1), date02 = rnorm(n = 100, mean = 10, sd = 1)) print(head(bdd)) ## date01 date02 ## 1 11.288926 8.933653 ## 2 10.083652 10.732413 ## 3 8.608635 10.664755 ## 4 9.486194 11.656091 ## 5 7.394949 9.839024 ## 6 7.980404 11.124597 Nous voudrions quantifier la différence entre la première et la deuxième date, puis mettre un indicateur pour savoir si cette différence est petite ou grande, par exemple avec un seuil arbitraire de 3. Donc pour chaque ligne nous pourrions faire : bdd$dif &lt;- NA bdd$isDifBig &lt;- NA bdd$dif[1] &lt;- sqrt((bdd$date01[1] - bdd$date02[1])^2) bdd$dif[2] &lt;- sqrt((bdd$date01[2] - bdd$date02[2])^2) bdd$dif[3] &lt;- sqrt((bdd$date01[3] - bdd$date02[3])^2) # ... bdd$dif[100] &lt;- sqrt((bdd$date01[100] - bdd$date02[100])^2) if(bdd$dif[1] &gt; 3){ bdd$isDifBig[1] &lt;- &quot;big&quot; }else{ bdd$isDifBig[1] &lt;- &quot;small&quot; } if(bdd$dif[2] &gt; 3){ bdd$isDifBig[2] &lt;- &quot;big&quot; }else{ bdd$isDifBig[2] &lt;- &quot;small&quot; } if(bdd$dif[3] &gt; 3){ bdd$isDifBig[3] &lt;- &quot;big&quot; }else{ bdd$isDifBig[3] &lt;- &quot;small&quot; } # ... if(bdd$dif[100] &gt; 3){ bdd$isDifBig[100] &lt;- &quot;big&quot; }else{ bdd$isDifBig[100] &lt;- &quot;small&quot; } Cette façon de faire serait extrêmement fastidieuse à réaliser, et même presque impossible à réaliser si la table contenait 1000 ou 100000 lignes. Il pourrait sembler logique de vouloir itérer sur les lignes de notre data.frame pour obtenir les nouvelles colonnes. Nous allons le réaliser même si ce n’est pas la solution que nous allons retenir par la suite. Nous allons utiliser une boucle for(). La boucle for() va itérer sur les éléments d’un objet que nous allons donner en argument. Par exemple voici une boucle qui pour tous les chiffres de 3 à 9 va calculer leur valeur au carré. La valeur courante du chiffre est symbolisé par un objet qui peut prendre le nom que nous souhaitons (ici cela sera i). for(i in c(3, 4, 5, 6, 7, 8, 9)){ print(i^2) } ## [1] 9 ## [1] 16 ## [1] 25 ## [1] 36 ## [1] 49 ## [1] 64 ## [1] 81 Que nous pouvons améliorer en utilisant la fonction :. for(i in 3:9){ print(i^2) } Le choix du nom i est ici arbitraire, nous aurions pu choisir myVarFor de la même façon : for(myVarFor in 3:9){ print(myVarFor^2) } La boucle for() peut itérer sur tous les types d’éléments. nChar &lt;- c(&quot;a&quot;, &quot;z&quot;, &quot;e&quot;, &quot;r&quot;, &quot;t&quot;, &quot;y&quot;) for(i in nChar){ print(i) } ## [1] &quot;a&quot; ## [1] &quot;z&quot; ## [1] &quot;e&quot; ## [1] &quot;r&quot; ## [1] &quot;t&quot; ## [1] &quot;y&quot; Revenons à notre cas. Nous allons itérer sur le nombre de lignes de notre data.frame bdd. Avant cela nous allons créer les colonnes dif et isDifBig avec les valeurs NA. Ensuite nous allons utiliser la fonction nrow() pour connaître le nombre de lignes. bdd$dif &lt;- NA bdd$isDifBig &lt;- NA for(i in 1:nrow(bdd)){ bdd$dif[i] &lt;- sqrt((bdd$date01[i] - bdd$date02[i])^2) if(bdd$dif[i] &gt; 3){ bdd$isDifBig[i] &lt;- &quot;big&quot; }else{ bdd$isDifBig[i] &lt;- &quot;small&quot; } } print(head(bdd, n = 20)) ## date01 date02 dif isDifBig ## 1 11.288926 8.933653 2.3552736 small ## 2 10.083652 10.732413 0.6487605 small ## 3 8.608635 10.664755 2.0561198 small ## 4 9.486194 11.656091 2.1698971 small ## 5 7.394949 9.839024 2.4440756 small ## 6 7.980404 11.124597 3.1441936 big ## 7 8.442444 9.890612 1.4481675 small ## 8 9.497397 10.449915 0.9525181 small ## 9 9.389723 8.086636 1.3030871 small ## 10 10.154902 10.452305 0.2974033 small ## 11 10.044377 10.454496 0.4101192 small ## 12 8.592562 12.470820 3.8782584 big ## 13 10.331942 11.026389 0.6944475 small ## 14 11.134954 9.877098 1.2578555 small ## 15 10.698497 9.029343 1.6691542 small ## 16 10.186106 9.513091 0.6730143 small ## 17 9.905806 8.617691 1.2881147 small ## 18 10.082094 11.475609 1.3935146 small ## 19 11.624378 9.294796 2.3295820 small ## 20 9.672238 10.514960 0.8427221 small En pratique ce n’est pas la meilleure façon de réaliser cet exercice car il s’agit ici de simples calculs sur des vecteurs contenus dans une data.frame. R est particulièrement puissant pour effectuer des opérations sur des vecteurs. Lorsque cela est possible il faut donc toujours privilégier les opérations sur les vecteurs. Ici notre code devient : bdd$dif &lt;- sqrt((bdd$date01 - bdd$date02)^2) bdd$isDifBig &lt;- &quot;small&quot; bdd$isDifBig[bdd$dif &gt; 3] &lt;- &quot;big&quot; print(head(bdd, n = 20)) ## date01 date02 dif isDifBig ## 1 11.288926 8.933653 2.3552736 small ## 2 10.083652 10.732413 0.6487605 small ## 3 8.608635 10.664755 2.0561198 small ## 4 9.486194 11.656091 2.1698971 small ## 5 7.394949 9.839024 2.4440756 small ## 6 7.980404 11.124597 3.1441936 big ## 7 8.442444 9.890612 1.4481675 small ## 8 9.497397 10.449915 0.9525181 small ## 9 9.389723 8.086636 1.3030871 small ## 10 10.154902 10.452305 0.2974033 small ## 11 10.044377 10.454496 0.4101192 small ## 12 8.592562 12.470820 3.8782584 big ## 13 10.331942 11.026389 0.6944475 small ## 14 11.134954 9.877098 1.2578555 small ## 15 10.698497 9.029343 1.6691542 small ## 16 10.186106 9.513091 0.6730143 small ## 17 9.905806 8.617691 1.2881147 small ## 18 10.082094 11.475609 1.3935146 small ## 19 11.624378 9.294796 2.3295820 small ## 20 9.672238 10.514960 0.8427221 small La plupart des exemples que l’on peut trouver sur Internet à propos de la boucle for() peuvent être remplacés par des opérations sur les vecteurs. Voici quelques exemples adaptés de plusieurs sources : # tester si des nombres sont pairs # [1] FOR x &lt;- sample(1:100, size = 20) count &lt;- 0 for (val in x) { if(val %% 2 == 0){ count &lt;- count + 1 } } print(count) ## [1] 10 # [2] VECTOR sum(x %% 2 == 0) ## [1] 10 # calculer des carrés # [1] FOR x &lt;- rep(0, 20) for (j in 1:20){ x[j] &lt;- j^2 } print(x) ## [1] 1 4 9 16 25 36 49 64 81 100 121 144 169 196 225 256 289 ## [18] 324 361 400 # [2] VECTOR (1:20)^2 ## [1] 1 4 9 16 25 36 49 64 81 100 121 144 169 196 225 256 289 ## [18] 324 361 400 # répéter un lancer de dés et faire la moyenne # [1] FOR ntrials = 1000 trials = rep(0, ntrials) for (j in 1:ntrials){ trials[j] = sample(1:6, size = 1) } mean(trials) ## [1] 3.539 # [2] VECTOR mean(sample(1:6, ntrials, replace = TRUE)) ## [1] 3.599 C’est un bon exercice de parcourir les nombreux exemples disponibles sur Internet sur la boucle for() et de tenter de les transformer en opérations vectorielles. Cela nous permet d’acquérir les bons réflexes de programmation avec R. La boucle for() reste très utile pour par exemple lire plusieurs fichiers et traiter l’information qu’ils contiennent de la même façon, faire des graphiques, ou encore lorsque les opérations vectorielles deveinnent fastidieuses. Imaginons une matrice de 10 colonnes et 100 lignes. Nous voulons la somme de chaque ligne (nous verrons plus loin comment faire avec la fonction apply()). myMat &lt;- matrix(sample(1:100, size = 1000, replace = TRUE), ncol = 10) # VECTOR sumRow &lt;- myMat[, 1] + myMat[, 2] + myMat[, 3] + myMat[, 4] + myMat[, 5] + myMat[, 6] + myMat[, 7] + myMat[, 8] + myMat[, 9] + myMat[, 10] print(sumRow) ## [1] 453 387 351 582 713 609 456 358 456 502 528 547 502 640 440 576 492 ## [18] 497 439 522 734 539 597 387 501 401 574 588 490 374 573 528 595 452 ## [35] 432 561 441 433 388 379 512 376 618 581 588 644 510 725 480 545 600 ## [52] 626 480 574 386 525 435 464 456 731 530 447 386 579 429 523 554 685 ## [69] 569 411 389 438 413 525 418 385 584 351 419 463 482 426 613 564 491 ## [86] 611 589 626 479 454 486 515 410 550 479 489 507 459 503 550 # FOR sumRow &lt;- rep(NA, times = nrow(myMat)) for(j in 1:nrow(myMat)){ sumRow[j] &lt;- sum(myMat[j, ]) } print(sumRow) ## [1] 453 387 351 582 713 609 456 358 456 502 528 547 502 640 440 576 492 ## [18] 497 439 522 734 539 597 387 501 401 574 588 490 374 573 528 595 452 ## [35] 432 561 441 433 388 379 512 376 618 581 588 644 510 725 480 545 600 ## [52] 626 480 574 386 525 435 464 456 731 530 447 386 579 429 523 554 685 ## [69] 569 411 389 438 413 525 418 385 584 351 419 463 482 426 613 564 491 ## [86] 611 589 626 479 454 486 515 410 550 479 489 507 459 503 550 En conclusion, il est recommandé de ne pas utiliser la boucle for() avec R chaque fois que cela est possible, et nous verrons dans ce chapitre des alternatives commes les boucles de la famille apply(). 10.4 La boucle while La boucle while(), contrairement à la boucle for(), signifie TANT QUE. Tant qu’une condition n’est pas remplie, la boucle va continuer à s’exécuter. Attention car en cas d’erreur, nous pouvons facilement programmer des boucles qui ne terminent jamais ! Cette boucle est moins courante que la boucle for(). prenons un exemple : i &lt;- 0 while(i &lt; 10){ print(i) i &lt;- i + 1 } ## [1] 0 ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 Dans cet exemple, la variable i a comme valeur 0. TANT QUE i &lt; 10, nous allons afficher i. Pour que cette boucle se termine, il ne faut pas oublier de modifier la valeur de i, c’est ce qui est fait avec la ligne i &lt;- i + 1. Lorsque la condition i &lt; 10 ne se vérifie plus, la boucle s’arrête. La boucle while() est très utile pour créer des scripts qui vont effectuer des calculs sur des variables dont la valeur évoluent dans le temps. Par exemple imaginons un nombre entre 0 et 10000 et un générateur aléatoire qui va essayer de déterminer la valeur de ce nombre. Si nous souhaitons limiter les tentatives de R à 2 secondes, nous pouvons écrire le script suivant (qui devrait marcher à tous les coups sur un ordinateur de bureau classique pouvant facilement effectuer 35000 essais en 2 secondes) : myNumber &lt;- sample(x = 10000, size = 1) myGuess &lt;- sample(x = 10000, size = 1) startTime &lt;- Sys.time() numberGuess &lt;- 0 while(Sys.time() - startTime &lt; 2){ if(myGuess == myNumber){ numberGuess &lt;- numberGuess + 1 print(&quot;Number found !&quot;) print(paste0(&quot;And I have plenty of time left: &quot;, round(2 - as.numeric(Sys.time() - startTime), digits = 2), &quot; sec&quot;)) break }else{ myGuess &lt;- sample(x = 10000, size = 1) numberGuess &lt;- numberGuess + 1 } } ## [1] &quot;Number found !&quot; ## [1] &quot;And I have plenty of time left: 1.24 sec&quot; Dans ce script nous générons un nombre aléatoire à deviner avec la fonction sample(), et chaque essai avec la même fonction sample(). Ensuite nous utilisons la fonction Sys.time() (avec un S majuscule à Sys), pour connaître l’heure de début de la boucle. Tant que la différence entre chaque itération de la boucle et l’heure de démarrage est inférieur à 2 secondes, la boucle while() va vérifier si le bon nombre a été deviner dans le test logique avec if() puis si c’est le cas nous informer que le nombre a été trouvé, nous dire le temps restant avant les deux secondes, puis terminer la boucle avec le mot clef break sur lequel nous reviendrons. En bref, break permet de sortir d’une boucle. Si le nombre n’a pas été deviné, la boucle fait un autre essai avec la fonction sample(). Plus concrètement nous pourrions imaginer des algorithmes pour explorer un espace de solutions face à un problème avec un temps limité pour y parvenir. La boucle while() peut aussi être pratique pour qu’un script ne s’exécute que lorsque un fichier issu d’un autre programme devient disponible… En pratique la boucle while() reste peu utilisée avec R. 10.5 La boucle repeat La boucle repeat() permet de répéter une opération sans condition à vérifier. Pour sortir de cette boucle il faut donc obligatoirement utiliser le mot clef break. i &lt;- 1 repeat{ print(i^2) i &lt;- i + 1 if(i == 5){ break } } ## [1] 1 ## [1] 4 ## [1] 9 ## [1] 16 Si nous reprenons l’exemple précédent, nous pouvons utiliser une boucle repeat() pour le répéter 5 fois. numTry &lt;- 0 repeat{ myNumber &lt;- sample(x = 10000, size = 1) myGuess &lt;- sample(x = 10000, size = 1) startTime &lt;- Sys.time() numberGuess &lt;- 0 while(Sys.time() - startTime &lt; 2){ if(myGuess == myNumber){ numberGuess &lt;- numberGuess + 1 print(round(as.numeric(Sys.time() - startTime), digits = 3)) break }else{ myGuess &lt;- sample(x = 10000, size = 1) numberGuess &lt;- numberGuess + 1 } } numTry &lt;- numTry + 1 if(numTry == 5){break} } ## [1] 0.609 ## [1] 0.59 ## [1] 0.078 ## [1] 1.453 ## [1] 0.828 Comme la boucle while(), la boucle repeat() reste peu utilisée avec R. 10.6 next et break Nous avons déjà vu le mot clef break qui permet de sortir de la boucle en cours. Par exemple si nous cherchons le premier chiffre après 111 qui soit divisible par 32 : myVars &lt;- 111:1000 for(myVar in myVars){ if(myVar %% 32 == 0){ print(myVar) break } } ## [1] 128 Même si nous avons vu que dans la pratique nous pouvons éviter la boucle for() avec une opération sur les vecteurs : (111:1000)[111:1000 %% 32 == 0][1] ## [1] 128 Le mot clef next permet quant à lui de passer à l’itération suivante d’une boucle si une certaine condition est remplie. Par exemple si nous voulons imprimer les lettre de l’alphabet sans les voyelles : for(myLetter in letters){ if(myLetter %in% c(&quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;y&quot;)){ next } print(myLetter) } ## [1] &quot;b&quot; ## [1] &quot;c&quot; ## [1] &quot;d&quot; ## [1] &quot;f&quot; ## [1] &quot;g&quot; ## [1] &quot;h&quot; ## [1] &quot;j&quot; ## [1] &quot;k&quot; ## [1] &quot;l&quot; ## [1] &quot;m&quot; ## [1] &quot;n&quot; ## [1] &quot;p&quot; ## [1] &quot;q&quot; ## [1] &quot;r&quot; ## [1] &quot;s&quot; ## [1] &quot;t&quot; ## [1] &quot;v&quot; ## [1] &quot;w&quot; ## [1] &quot;x&quot; ## [1] &quot;z&quot; Encore une fois nous pourrions éviter la boucle for() avec : letters[! letters %in% c(&quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;y&quot;)] ## [1] &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; &quot;t&quot; &quot;v&quot; ## [18] &quot;w&quot; &quot;x&quot; &quot;z&quot; En conclusion, si nous utilisons les boucles, alors les mots clefs next et break sont souvent très utiles, mais chaque fois que cela est possible il vaut mieux avoir recours à des opérations sur les vecteurs. Lorsque cela n’est pas possible de travailler sur les vecteurs, il est préférable d’utiliser les boucles de la famille apply qui sont le sujet de la prochaine section. 10.7 Les boucles de la famille apply 10.7.1 apply La fonction apply() permet d’appliquer une fonction à tous les éléments d’un array ou d’une matrix. Par exemple si nous souhaitons connaître la somme de chaque ligne d’une matrix de 10 colonnes et 100 lignes : myMat &lt;- matrix(sample(1:100, size = 1000, replace = TRUE), ncol = 10) apply(X = myMat, MARGIN = 1, FUN = sum) ## [1] 408 479 535 572 501 467 322 343 518 550 430 557 533 375 550 461 549 ## [18] 592 585 487 351 566 552 494 487 673 479 497 408 464 530 512 484 590 ## [35] 425 495 504 580 656 535 307 406 619 464 549 527 684 480 372 394 573 ## [52] 399 510 523 563 618 493 503 427 511 445 812 329 515 518 612 475 386 ## [69] 507 452 413 441 546 581 576 523 601 572 567 490 393 321 482 487 443 ## [86] 603 428 500 643 633 576 535 575 381 390 452 434 459 342 543 Si nous souhaitons connaître la médiane de chaque colonne, l’expression devient : apply(X = myMat, MARGIN = 2, FUN = median) ## [1] 45.5 50.5 47.0 50.0 47.0 48.0 52.5 55.5 46.5 51.5 L’argument X correspond à l’objet sur lequel la boucle apply va itérer. L’argument MARGIN correspond à la dimension à prendre en compte (1 pour les lignes, et 2 pour les colonnes). L’argument FUN correspond à la fonction à appliquer. Sur un objet de type array, l’argument MARGIN peut prendre autant de valeurs que de dimensions. Dans cet exemple MARGIN = 1 correspond à la moyenne de chaque ligne - dimension 1 - (toutes dimensions confondues), MARGIN = 2 correspond à la moyenne de chaque colonne - dimension 2 - (toutes dimensions confondues), et MARGIN = 3 correspond à la moyenne de chaque dimension 3. Ci-dessous chaque calcul est réalisé de deux manières différentes pour en expliciter le fonctionnement. myArr &lt;- array(sample(1:100, size = 1000, replace = TRUE), dim = c(10, 20, 5)) apply(X = myArr, MARGIN = 1, FUN = mean) ## [1] 50.60 53.60 53.48 50.37 51.72 45.51 47.30 50.99 47.05 48.16 (apply(myArr[,,1], 1, mean) + apply(myArr[,,2], 1, mean) + apply(myArr[,,3], 1, mean) + apply(myArr[,,4], 1, mean) + apply(myArr[,,5], 1, mean))/5 ## [1] 50.60 53.60 53.48 50.37 51.72 45.51 47.30 50.99 47.05 48.16 apply(X = myArr, MARGIN = 2, FUN = mean) ## [1] 51.04 46.82 54.04 53.02 50.44 50.70 46.20 48.32 48.64 55.10 43.94 ## [12] 47.52 52.12 46.10 56.06 51.12 50.82 47.46 51.38 46.72 (apply(myArr[,,1], 2, mean) + apply(myArr[,,2], 2, mean) + apply(myArr[,,3], 2, mean) + apply(myArr[,,4], 2, mean) + apply(myArr[,,5], 2, mean))/5 ## [1] 51.04 46.82 54.04 53.02 50.44 50.70 46.20 48.32 48.64 55.10 43.94 ## [12] 47.52 52.12 46.10 56.06 51.12 50.82 47.46 51.38 46.72 apply(X = myArr, MARGIN = 3, FUN = mean) ## [1] 46.815 48.735 52.485 48.000 53.355 c(mean(myArr[,,1]), mean(myArr[,,2]), mean(myArr[,,3]), mean(myArr[,,4]), mean(myArr[,,5])) ## [1] 46.815 48.735 52.485 48.000 53.355 Nous pouvons aussi calculer la moyenne pour chaque valeur de ligne et de colonne (la fonction itère alors sur la dimension 3) : apply(X = myArr, MARGIN = c(1, 2), FUN = mean) ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] ## [1,] 45.2 46.4 55.8 34.0 57.6 65.4 32.6 42.4 61.2 56.2 38.0 58.4 43.8 ## [2,] 68.0 44.8 46.0 62.0 65.8 50.4 49.4 52.2 53.8 60.0 44.4 41.6 61.0 ## [3,] 43.8 20.0 58.4 65.4 56.2 63.0 52.0 65.0 24.2 53.2 45.2 45.0 77.8 ## [4,] 44.8 45.0 42.0 37.4 51.6 62.6 57.0 33.0 63.6 56.2 42.2 35.0 61.4 ## [5,] 46.6 56.0 57.6 64.6 31.2 53.8 55.0 65.0 53.0 62.8 44.8 31.2 53.6 ## [6,] 62.0 37.8 52.2 26.2 56.0 49.2 28.4 21.2 48.6 73.8 39.8 37.4 35.8 ## [7,] 64.4 66.0 65.2 74.0 39.0 32.4 43.8 72.2 47.8 43.4 47.6 63.8 36.4 ## [8,] 54.6 34.2 61.0 47.2 57.6 30.6 42.6 46.0 66.8 48.2 57.8 65.0 63.2 ## [9,] 34.2 64.4 65.4 60.4 26.4 36.6 55.0 44.2 41.2 60.4 47.2 44.8 45.0 ## [10,] 46.8 53.6 36.8 59.0 63.0 63.0 46.2 42.0 26.2 36.8 32.4 53.0 43.2 ## [,14] [,15] [,16] [,17] [,18] [,19] [,20] ## [1,] 56.2 71.0 35.8 48.6 44.2 75.0 44.2 ## [2,] 46.0 66.2 58.6 53.8 58.4 42.4 47.2 ## [3,] 65.6 45.4 67.8 52.6 59.2 60.2 49.6 ## [4,] 62.4 64.0 62.0 53.2 42.8 47.2 44.0 ## [5,] 48.8 65.0 51.6 29.4 53.2 60.4 50.8 ## [6,] 30.2 62.4 74.0 60.8 32.6 48.0 33.8 ## [7,] 42.8 31.8 22.4 44.6 44.4 35.0 29.0 ## [8,] 34.2 52.4 35.4 59.6 52.6 53.0 57.8 ## [9,] 36.6 37.6 50.8 52.6 33.4 39.8 65.0 ## [10,] 38.2 64.8 52.8 53.0 53.8 52.8 45.8 10.7.2 lapply Comme indiqué dans la documentation, lapply() renvoie une liste de même longueur que X, chaque élément résultant de l’application de FUN à l’élément correspondant de X. Si X est une list contenant des vector et que nous cherchons à obtenir la moyenne de chacun des éléments de la list, nous pouvons utiliser la fonction lapply() : myList &lt;- list( a = sample(1:100, size = 10), b = sample(1:100, size = 10), c = sample(1:100, size = 10), d = sample(1:100, size = 10), e = sample(1:100, size = 10) ) print(myList) ## $a ## [1] 21 25 82 41 98 36 70 33 5 81 ## ## $b ## [1] 95 68 73 24 13 16 11 62 82 49 ## ## $c ## [1] 71 14 99 44 83 17 65 28 48 38 ## ## $d ## [1] 50 88 82 25 91 97 44 65 11 70 ## ## $e ## [1] 36 81 35 53 97 94 46 48 89 60 lapply(myList, FUN = mean) ## $a ## [1] 49.2 ## ## $b ## [1] 49.3 ## ## $c ## [1] 50.7 ## ## $d ## [1] 62.3 ## ## $e ## [1] 63.9 Comme pour la fonction apply(), nous pouvons passer des arguments supplémentaires à la fonction lapply() en les ajoutant à la suite de la fonction. C’est par exemple utile si notre list contient ces valeurs manquantes NA et que nous voulons les ignorer pour le calcul des moyennes (avec l’arguement na.rm = TRUE). myList &lt;- list( a = sample(c(1:5, NA), size = 10, replace = TRUE), b = sample(c(1:5, NA), size = 10, replace = TRUE), c = sample(c(1:5, NA), size = 10, replace = TRUE), d = sample(c(1:5, NA), size = 10, replace = TRUE), e = sample(c(1:5, NA), size = 10, replace = TRUE) ) print(myList) ## $a ## [1] 4 5 4 5 5 3 NA 1 1 3 ## ## $b ## [1] 5 3 NA 3 1 5 4 4 3 NA ## ## $c ## [1] 2 4 3 NA NA 1 3 NA NA 3 ## ## $d ## [1] NA 5 3 2 5 1 3 3 1 5 ## ## $e ## [1] NA 1 4 1 3 1 3 3 5 2 lapply(myList, FUN = mean) ## $a ## [1] NA ## ## $b ## [1] NA ## ## $c ## [1] NA ## ## $d ## [1] NA ## ## $e ## [1] NA lapply(myList, FUN = mean, na.rm = TRUE) ## $a ## [1] 3.444444 ## ## $b ## [1] 3.5 ## ## $c ## [1] 2.666667 ## ## $d ## [1] 3.111111 ## ## $e ## [1] 2.555556 Pour plus de lisibilité ou si plusieurs opérations sont à réaliser au sein de l’argument FUN, nous pouvons utiliser l’écriture suivante : lapply(myList, FUN = function(i){ mean(i, na.rm = TRUE) }) ## $a ## [1] 3.444444 ## ## $b ## [1] 3.5 ## ## $c ## [1] 2.666667 ## ## $d ## [1] 3.111111 ## ## $e ## [1] 2.555556 Par exemple si nous souhaitons obtenir i^2 si la moyenne est supérieure à 3, et i^3 sinon : lapply(myList, FUN = function(i){ m &lt;- mean(i, na.rm = TRUE) if(m &gt; 3){ return(i^2) }else{ return(i^3) } }) ## $a ## [1] 16 25 16 25 25 9 NA 1 1 9 ## ## $b ## [1] 25 9 NA 9 1 25 16 16 9 NA ## ## $c ## [1] 8 64 27 NA NA 1 27 NA NA 27 ## ## $d ## [1] NA 25 9 4 25 1 9 9 1 25 ## ## $e ## [1] NA 1 64 1 27 1 27 27 125 8 10.7.3 sapply La fonction sapply() est une version modifiée de la fonction lapply() qui effectue la même opération mais en renvoyant le résultat sous un format simplifié lorsque c’est possible. lapply(myList, FUN = function(i){ mean(i, na.rm = TRUE) }) ## $a ## [1] 3.444444 ## ## $b ## [1] 3.5 ## ## $c ## [1] 2.666667 ## ## $d ## [1] 3.111111 ## ## $e ## [1] 2.555556 sapply(myList, FUN = function(i){ mean(i, na.rm = TRUE) }) ## a b c d e ## 3.444444 3.500000 2.666667 3.111111 2.555556 La fonction sapply() est intéressante pour récupérer par exemple le nième élément de chacun des éléments d’une list. La fonction qui est appelée pour faire cela est '[['. sapply(myList, FUN = &#39;[[&#39;, 2) ## a b c d e ## 5 3 4 5 1 10.7.4 tapply La fonctiontapply() permet d’appliquer une fonction en prenant comme élément à itérer une variable existante. Imaginons des informations sur des espèces représentées par des lettres majuscules (e.g., A, B, C) et des valeurs de performances à différentes localisations. species &lt;- sample(LETTERS[1:10], size = 1000, replace = TRUE) perf1 &lt;- rnorm(n = 1000, mean = 10, sd = 0.5) perf2 &lt;- rlnorm(n = 1000, meanlog = 10, sdlog = 0.5) perf3 &lt;- rgamma(n = 1000, shape = 10, rate = 0.5) dfSpecies &lt;- data.frame(species, perf1, perf2, perf3) print(head(dfSpecies, n = 10)) ## species perf1 perf2 perf3 ## 1 F 10.944779 32647.289 17.14780 ## 2 G 9.882232 7494.628 20.18062 ## 3 J 10.018781 26774.939 14.36881 ## 4 J 10.290984 13115.707 26.36773 ## 5 D 9.968266 18760.593 25.91686 ## 6 C 9.798818 8029.450 12.80674 ## 7 J 10.605967 13167.094 15.91625 ## 8 D 10.246191 28000.603 29.89719 ## 9 E 10.364610 32528.506 17.28390 ## 10 E 9.381790 15876.087 16.13087 Nous pouvons facilement obtenir un résumé des performances pour chaque espèce avec la fonction tapply() et la fonction summary(). tapply(dfSpecies$perf1, INDEX = dfSpecies$species, FUN = summary) ## $A ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 8.463 9.633 10.024 10.015 10.375 11.184 ## ## $B ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 8.909 9.747 9.978 10.022 10.363 11.368 ## ## $C ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 8.810 9.733 10.013 10.010 10.319 11.160 ## ## $D ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 8.675 9.587 9.981 9.947 10.269 11.216 ## ## $E ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 8.463 9.566 9.977 9.944 10.337 11.134 ## ## $F ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 8.668 9.683 10.015 10.045 10.492 11.272 ## ## $G ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 9.048 9.730 10.014 10.048 10.380 10.839 ## ## $H ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 8.687 9.710 10.046 10.033 10.369 11.325 ## ## $I ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 8.342 9.612 9.950 9.964 10.391 11.339 ## ## $J ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 8.397 9.745 10.126 10.075 10.421 11.070 Nous pouvons aussi obtenir la valeur moyenne de chacune des performances en combinant une fonction sapply() avec la fonction tapply()et en utilisant la fonction mean(). sapply(2:4, FUN = function(i){ tapply(dfSpecies[,i], INDEX = dfSpecies$species, FUN = mean) }) ## [,1] [,2] [,3] ## A 10.015229 27892.56 19.42984 ## B 10.022167 23481.29 20.68156 ## C 10.009910 26030.20 19.37910 ## D 9.947188 25146.14 19.39769 ## E 9.943974 24961.35 19.39636 ## F 10.045339 25370.15 19.84466 ## G 10.047912 26654.85 19.18667 ## H 10.033202 25884.77 19.60622 ## I 9.964380 24771.48 20.14581 ## J 10.075312 25742.48 20.41847 10.7.5 mapply La fonction mapply() est une version de la fonction sapply()qui utilise de multiples arguments. Par exemple si nous avons une liste de deux éléments 1:5 et 5:1 et que nous souhaitons ajouter 10 au premier élément et 100 au deuxième élément : mapply(FUN = function(i, j){i+j}, i = list(1:5, 5:1), j = c(10, 100)) ## [,1] [,2] ## [1,] 11 105 ## [2,] 12 104 ## [3,] 13 103 ## [4,] 14 102 ## [5,] 15 101 10.8 Conclusion Félicitations, nous sommes arrivés au bout de ce chapitre sur l’algorithmique. Retenons ce message clef : dès qu’une opération doit être réalisée plus de deux fois dans un script en répétant du code qui a été déjà écrit, c’est un signe qui doit nous conduire à l’utilisation d’une boucle. Pour autant, chaque fois que cela est possible, il est recommandé de ne pas utiliser les boucles traditionnelles for(), while(), et repeat(), mais de préférer les opérations sur les vecteurs ou encore les boucles de la famille apply. Cela peut être assez difficile à intégrer au début mais nous verrons que nos scripts seront plus faciles à maintenir et à lire, et beaucoup plus performants si nous suivons ces habitudes. "]
]
