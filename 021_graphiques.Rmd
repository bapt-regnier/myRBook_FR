# (PART) Les graphiques {-}

# Graphiques simples {#graph1}

## `plot`

Le premier type de graphique que nous allons voir est le nuage de points. Dans un nuage de points, chaque point est représenté par sa valeur en x et en y. La fonction permettant de faire un nuage de points est `plot()`. 

```{r}
myX <- rnorm(50, mean = 0, sd = 1)
myY <- rnorm(50, mean = 10, sd = 1)
plot(x = myX, y = myY)
```

Comme pour tous les types de graphiques, nous pouvons ajouter une légende sur l'axe des x et des y.

```{r}
plot(x = myX, y = myY, 
  xlab = "X", ylab = "Y")
```

Nous pouvons aussi définir les limites des axes en X et en Y.

```{r}
plot(x = myX, y = myY, 
  xlab = "X", ylab = "Y", 
  xlim = c(-3, 3), ylim = c(7, 13))
```

Le type de point peut être défini avec l'argument `pch` qui peut prendre un caratère ou un chiffre de 1 à 25.

```{r}
plot(x = rep(seq(1:5), 5), y = rep(seq(1:5), each = 5),
  pch = 1:25)
plot(x = myX, y = myY, 
  pch = c("a", "@", "#", "1", "=", "-", "_", "o", "O", "0", letters[1:15]))
```

La taille des points peut se définir avec l'argument `cex`.

```{r}
plot(x = myX, y = myY, 
  cex = seq(from = 0.5, to = 3, length.out = 50))
```

La couleur des points peut se définir avec l'argument `col`. Nous reviendrons sur les couleurs dans un prochain chapitre.

```{r}
myX <- rnorm(100, mean = 0, sd = 1)
myY <- rnorm(100, mean = 10, sd = 1)
plot(x = myX, y = myY, 
  cex = seq(from = 0.5, to = 3, length.out = 100),
  pch = 16,
  col = sample(colors(), 100))
```

R offre la possibilité de relier les points des nuages de points de différentes façons. Les différentes options sont disponibles dans l'aide de la fonction `plot()` et `plot.default()`.

```{r}
myX <- 1:20
myY <- rnorm(20, mean = 10, sd = 1)
plot(x = myX, y = myY, 
  type = 'b') # 'p', 'l', 'b', 'c', 'o', 'h', 's', 'S', 'n'
```

Une dernière option très utile est l'argument `panel.first` qui permet de réaliser une opération graphique sur une couche située en dessous de notre graphique. Voici un exemple illustratif avec une grille réalisée avec et sans `panel.first`. La grille se fait grâce à la fonction `grid()`. Pour mettre les graphiques côte à côte nous allons utiliser `mfrow`.

```{r}
par(mfrow = c(1, 2))
plot(x = myX, y = myY, 
  type = 'b', pch = 16, cex = 3) 
grid(lwd = 3, lty = 1)
plot(x = myX, y = myY, 
  type = 'b', pch = 16, cex = 3, 
  panel.first = grid(lwd = 3, lty = 1)) 
par(mfrow = c(1, 1))
```

La fonction `par()` permet d'accéder aux paramètres graphiques. Parmi ces paramètres il y a `mfrow` qui permet de diviser l'espace graphique comme une matrice. `mfrow` prend comme arguments un vecteur numérique de taille 2 : le premier élément correspond au nombre de lignes et le deuxième élément au nombre de colonnes. Le paramètre `mar` permet de contrôler les marges en bas, à gauche, en haut et à droite, respectivement, au moyen d'un vecteur numérique de taille 4. Après avoir modifié les paramètres graphiques par défaut il est recommandé de les réinitialiser pour que cela n'affecte pas les graphiques à venir. Les valeurs par défaut de `mfrow` sont `c(1, 1)` et `mar = c(4, 4, 4, 4)`. Nous pouvons remettre ces valeurs par défaut comme ci-dessus en redéfinissant chacun des paramètres. Nous pouvons également enregistrer au préalable les valeurs courantes (dans un objet `op`), puis les modifier pour les besoins de nos graphiques, puis ensuite rappeler les valeurs contenues dans l'objet `op`. Ici nous utilisons `lapply` pour réaliser rapidement quatre graphiques.

```{r}
op <- par(no.readonly = TRUE)
par(mfrow = c(2, 2), mar = c(2, 2, 1, 1))
graph4 <- lapply(1:4, function(i){
  plot(x = rnorm(100), 
    y = rnorm(100), 
    col = i, pch = 16)
})
par(op)
```

Il est souvent utile de faire figurer des lignes verticales ou horizontales pour représenter des valeurs particulières. Ces lignes peuvent être ajoutées avec la fonction `abline()`. 

```{r}
myX <- rnorm(100)
myY <- rnorm(100)
plot(x = myX, y = myY, 
  xlim = c(-4, 4), ylim = c(-4, 4),   
  pch = 16, cex = 1.5, 
  col = sample(colors(), size = 100),
  panel.first = {
    grid()
    abline(v = c(min(myX), max(myX)), lty = 2)
    abline(h = c(min(myY), max(myY)), lty = 2)
    abline(v = mean(myX), lty = 1)
    abline(h = mean(myY), lty = 1)
})
```

## `hist`

Pour faire un histogramme nous utilisons la fonction `hist()`. C'est une fonction graphique utile pour visualiser rapidement la distribution d'un jeu de données. 

```{r}
op <- par(no.readonly = TRUE)
par(mfrow = c(2, 2), mar = c(2, 2, 1, 1))
myX <- list(
  rnorm(1000),
  rgamma(1000, shape = 1),
  sample(1:100, size = 1000, replace = TRUE),
  rbeta(1000, shape1 = 1, shape2 = 2)
)
myTitle <- list("Normal", "Gamma", "Uniform", "Beta")
lapply(1:4, function(i){
  hist(myX[[i]], 
    col = heat.colors(15), 
    main = myTitle[[i]]
  )
})
par(op)
```

## `barplot`

Le graphique en barres se fait au moyen de la fonction `barplot()`.

```{r}
myX <- c(4, 5, 8)
barplot(myX, names.arg = c("A", "B", "C"))
```

Quand l'objet envoyé à cette fonction est un `vector()` alors la fonction `barplot()` renvoie un graphique en barres simples. Quand c'est une `matrix()` alors les barres sont multiples.

```{r}
op <- par(no.readonly = TRUE)
par(mfrow = c(1, 2), mar = c(2, 2, 1, 1))
myX <- matrix(c(4, 5, 8, 4, 6, 2), nrow = 2)
barplot(myX, names.arg = c("A", "B", "C"))
myX <- matrix(c(4, 5, 8, 4, 6, 2, 3, 4, 5), nrow = 3)
barplot(myX, names.arg = c("A", "B", "C"))
par(op)
```

xxx

```{r}
op <- par(no.readonly = TRUE)
par(mar = c(2, 2, 1, 1))
myX <- rnorm(100)
myY <- rnorm(100)
myYCut <- table(cut(myY, breaks = -4:4))
myXCut <- table(cut(myX, breaks = -4:4))
layout(matrix(c(1, 1, 0, 
                2, 2, 3, 
                2, 2, 3), ncol = 3, byrow = TRUE))

barplot(myXCut, las = 3)
plot(x = myX, y = myY, 
     xlim = c(-4, 4), ylim = c(-4, 4), 
     panel.first = {grid()})
barplot(myYCut, las = 3, horiz = TRUE)
par(op)
```

## `boxplot`

## `image` et `contour`

# La gestion des couleurs {#graph2}

## `colors()`

## RGB

## Palettes

# Graphiques composés {#graph3}

## `mfrow`

## `layout`
